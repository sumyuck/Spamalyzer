import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Common spam indicator words (used for suspicious word detection)
const SPAM_INDICATORS = [
  'free', 'win', 'winner', 'cash', 'prize', 'claim', 'urgent', 'act now',
  'limited time', 'click here', 'call now', 'congratulations', 'selected',
  'bonus', 'guaranteed', 'offer expires', '$$$', '!!!', 'txt', 'text',
  'reply', 'mobile', 'award', 'won', 'discount', 'cheap', 'loan',
];

// Load model files (these should be generated by train_and_export.py)
// For now, we'll use a rule-based approach until ONNX support is added
function analyzeEmailRuleBased(emailText: string) {
  const lowerText = emailText.toLowerCase();
  const words = lowerText.split(/\s+/);
  
  // Find suspicious words
  const suspiciousWords: string[] = [];
  for (const indicator of SPAM_INDICATORS) {
    if (lowerText.includes(indicator.toLowerCase())) {
      suspiciousWords.push(indicator);
    }
  }
  
  // Calculate spam score based on indicators
  let score = 0;
  
  // Check for multiple exclamation marks
  const exclamationCount = (emailText.match(/!/g) || []).length;
  if (exclamationCount >= 3) score += 15;
  else if (exclamationCount >= 2) score += 10;
  
  // Check for all caps words
  const capsWords = words.filter(word => 
    word.length > 2 && word === word.toUpperCase() && /[A-Z]/.test(word)
  );
  if (capsWords.length >= 3) score += 15;
  else if (capsWords.length >= 1) score += 10;
  
  // Check for money symbols
  if (lowerText.includes('£') || lowerText.includes('$') || lowerText.includes('€')) {
    score += 10;
  }
  
  // Check for phone numbers (UK format)
  if (/\b0[0-9]{10}\b/.test(emailText)) score += 10;
  
  // Check for suspicious URLs
  if (lowerText.includes('http') || lowerText.includes('www.') || lowerText.includes('.com')) {
    score += 10;
  }
  
  // Suspicious words contribution
  score += Math.min(suspiciousWords.length * 8, 40);
  
  // Determine if spam
  const confidence = Math.min(score, 100);
  const isSpam = confidence >= 50;
  
  // Generate explanation
  let explanation = '';
  if (isSpam) {
    explanation = `This email appears to be SPAM. `;
    const reasons = [];
    
    if (suspiciousWords.length > 0) {
      reasons.push(`contains ${suspiciousWords.length} spam indicator words (${suspiciousWords.slice(0, 3).join(', ')}${suspiciousWords.length > 3 ? '...' : ''})`);
    }
    if (exclamationCount >= 2) {
      reasons.push(`uses excessive exclamation marks (${exclamationCount})`);
    }
    if (capsWords.length >= 1) {
      reasons.push(`contains ${capsWords.length} all-caps words`);
    }
    if (lowerText.includes('£') || lowerText.includes('$')) {
      reasons.push('contains money-related symbols');
    }
    if (/\b0[0-9]{10}\b/.test(emailText)) {
      reasons.push('includes phone numbers');
    }
    if (lowerText.includes('http') || lowerText.includes('www.')) {
      reasons.push('contains suspicious URLs');
    }
    
    explanation += 'Key indicators: ' + reasons.join(', ') + '.';
  } else {
    explanation = `This email appears to be SAFE. `;
    if (suspiciousWords.length > 0) {
      explanation += `While it contains some common words (${suspiciousWords.slice(0, 2).join(', ')}), the overall content and structure suggest it's a legitimate message.`;
    } else {
      explanation += 'No significant spam indicators were detected. The message appears to be genuine communication.';
    }
  }
  
  return {
    isSpam,
    confidence,
    suspiciousWords,
    explanation
  };
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { emailText } = await req.json();

    if (!emailText || typeof emailText !== 'string') {
      return new Response(
        JSON.stringify({ error: 'Invalid email text provided' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log('Analyzing email with length:', emailText.length);

    // Use rule-based analysis (matching your ML model's approach)
    const analysis = analyzeEmailRuleBased(emailText);

    console.log('Analysis complete:', { isSpam: analysis.isSpam, confidence: analysis.confidence });

    return new Response(
      JSON.stringify(analysis),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Unexpected error in analyze-email:', error);
    return new Response(
      JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
